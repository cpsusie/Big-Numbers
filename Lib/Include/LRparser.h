#pragma once

#include "AbstractParserTables.h"
#include "SourcePosition.h"

class Scanner;

namespace LRParsing {

class ParserStackElement {
public:
  USHORT         m_state;
  USHORT         m_symbol;
  SourcePosition m_pos;
  inline ParserStackElement()
    : m_state( 0)
    , m_symbol(0)
  {
  }
  inline ParserStackElement(USHORT state, USHORT symbol, const SourcePosition &pos)
    : m_state( state )
    , m_symbol(symbol)
    , m_pos(   pos   )
  {
  }
};

class LRparser {
private:
  // Current parserstate
  UINT                m_state;
  // Current inputsymbol
  int                 m_input;
  UINT                m_stackSize;
  ParserStackElement *m_parserStack;
  // Topelement of stack = parserStack[m_stackTop-1]
  UINT                m_stackTop;
  // Dont give errormessage when > 0. Decremented on every parsecycle
  // and set to m_cascadecount when PAaction return ParserError
  UINT                m_suppressError;
  // Suppress the next m_cascadecount parsererrors
  UINT                m_cascadeCount;
  // Maximal number of errors before terminate parse.
  UINT                m_maxErrorCount;
  // Count parsererrors
  UINT                m_errorCount;
  // Have we finished the parse
  bool                m_done;
  // Current lexeme
  TCHAR              *m_text;
  // Length of current lexeme
  int                 m_textLength;
  // Current SourcePosition
  SourcePosition      m_pos;
  // Length of current reduceproduction
  UINT                m_productionLength;
  // If true call debug on each parsecycle
  bool                m_debug;
  // Generated by parsergen.exe
  const AbstractParserTables &m_tables;
  // Lexical scanner. generated by lexgen.exe
  Scanner            *m_scanner;

  LRparser(const LRparser &src);                     // Not defined. Class not cloneable
  LRparser &operator=(const LRparser &rhs);          // Not defined. Class not cloneable

  void parserStackCreate(UINT stackSize);
  void parserStackDestroy();
  void stackOverflow();

  inline void parserStackInit() {
    m_stackTop = 0;
  }

  inline void parserStackShift(USHORT state, USHORT symbol, const SourcePosition &pos) {
    if(m_stackTop < m_stackSize - 1) {
      m_parserStack[m_stackTop++] = ParserStackElement(state, symbol, pos);
    } else {
      stackOverflow();
    }
  }

  inline const ParserStackElement &getParserStackTop(int fromTop = 0) const {
    return m_parserStack[m_stackTop-1-fromTop];
  }

  inline void parserStackPop(UINT count) {
    m_stackTop -= count;
  }

  inline void parserStackRestore(UINT newTop) {
    m_stackTop = newTop;
  }

  bool recover();
  void initialize();
  void dumpState();
protected:
  // Called for each reduction in the parse
  virtual int reduceAction(UINT prod) {
    return 0;
  }
  // Called before the first parsecycle
  virtual void userStackInit()                   = 0;
  // Called when LRparser shift in inputtoken
  virtual void userStackShiftSymbol(UINT symbol) = 0;
  // Pop count symbols from userstack
  virtual void userStackPopSymbols( UINT count ) = 0;
  // Push($$) to userstack. called at the end of each reduction
  virtual void userStackShiftLeftSide()          = 0;
  // $$ = $1
  virtual void defaultReduce(       UINT prod  ) = 0;
public:
  LRparser(const AbstractParserTables &tables, Scanner *lex = nullptr, UINT stackSize = 256);
  virtual ~LRparser();

  inline       int                   input()                             const { return m_input;                             }
  inline       UINT                  state()                             const { return m_state;                             }
  inline       bool                  stackEmpty()                        const { return m_stackTop == 0;                     }
  inline       UINT                  getStackHeight()                    const { return m_stackTop;                          }
  inline       UINT                  getStackSize()                      const { return m_stackSize;                         }
  void                               setStackSize(       UINT newSize  );
  inline const ParserStackElement   &getStackTopElement( UINT fromTop=0) const {
    assert(fromTop < m_stackTop);
    return m_parserStack[m_stackTop-1-fromTop];
  }
  inline       void                  setCascadeCount(    UINT value    )       { m_cascadeCount = value;                     }
  inline       UINT                  getCascadeCount()                   const { return m_cascadeCount;                      }
  inline       void                  setMaxErrorCount(   UINT value    )       { m_maxErrorCount = value;                    }
  inline       UINT                  getMaxErrorCount()                  const { return m_maxErrorCount;                     }
  inline       UINT                  getProductionLength(UINT prod     ) const { return m_tables.getProductionLength(prod);  }
  inline const String               &getSymbolName(      UINT symbol   ) const { return m_tables.getSymbolName(symbol);      }
  inline const AbstractParserTables &getParserTables()                   const { return m_tables;                            }
  inline       Scanner              *getScanner()                        const { return m_scanner;                           }
  inline       void                  setDebug(           bool newValue)        { m_debug = newValue;                         }
  inline       bool                  done()                              const { return m_done;                              }
  inline       bool                  accept()                            const { return m_errorCount == 0;                   }
  inline const TCHAR                *getText()                           const { return m_text;                              }
  inline       int                   getTextLength()                     const { return m_textLength;                        }
  inline       int                   getLineNumber()                     const { return m_pos.getLineNumber();               }
  // Return current sourceposition
  SourcePosition                     getPos()                            const;
  // Return sourceposition of symbol number i in current production. i = [1..prodlen]
  const SourcePosition              &getPos(UINT i)                      const;

  // Set new scanner, return old scanner
  Scanner *setScanner(Scanner *lex);

  // Return 0 on ok. < 0 on error.
  int parseBegin();
  // Return 0 on continue, nonzero will terminate parse.
  int parseStep();
  // Return 0 on accept. nonzero on error
  int parse();

  void error(const SourcePosition &pos, _In_z_ _Printf_format_string_ TCHAR const * const format, ...);
  // Called on every step of the parse if m_debug is true
  void debug(_In_z_ _Printf_format_string_ TCHAR const * const format, ...);
  // Errors can be caught by usersupplied error-handler
  virtual void verror(const SourcePosition &pos, _In_z_ _Printf_format_string_ TCHAR const * const format, va_list argptr);
  virtual void vdebug(_In_z_ _Printf_format_string_ TCHAR const * const format, va_list argptr);
};

}; // namespace LRParsing
