/* DO NOT EDIT THIS FILE - it is machine generated */
#line 24 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
#include "stdafx.h"
#include <HashMap.h>
#include "SqlLex.h"
#include "SqlSymbol.h"

static int nameOrKeyWord(const TCHAR *lexeme);

#line 7 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
// DFA State   0 [nonAccepting]
//   goto  1 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t
//   goto  2 on \n
//   goto  1 on \x0b
//   goto  3 on \r
//   goto  1 on \s
//   goto 32 on "
//   goto 34 on #
//   goto  4 on %
//   goto  5 on (
//   goto  6 on )
//   goto  7 on *
//   goto  8 on +
//   goto  9 on ,
//   goto 10 on -
//   goto 11 on .
//   goto 12 on /
//   goto 13 on 0123456789
//   goto 36 on :
//   goto 14 on <
//   goto 15 on =
//   goto 16 on >
//   goto 37 on ?
//   goto 17 on ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
//   goto 38 on |
// DFA State   1 [accepting, line  96 <;>]
//   goto  1 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
// DFA State   2 [accepting, line  97 <;>]
//   goto  2 on \n
// DFA State   3 [accepting, line  98 <;>]
//   goto  3 on \r
// DFA State   4 [accepting, line  67 <return MODOP;>]
// DFA State   5 [accepting, line  72 <return LPAR;>]
// DFA State   6 [accepting, line  73 <return RPAR;>]
// DFA State   7 [accepting, line  65 <return STAR;>]
//   goto 20 on *
// DFA State   8 [accepting, line  64 <return PLUS;>]
// DFA State   9 [accepting, line  71 <return COMMA;>]
// DFA State  10 [accepting, line  63 <return MINUS;>]
// DFA State  11 [accepting, line  70 <return DOT;>]
//   goto 33 on 0123456789
// DFA State  12 [accepting, line  66 <return DIVOP;>]
//   goto 21 on *
//   goto 22 on /
// DFA State  13 [accepting, line  43 <return NUMBER;>]
//   goto 33 on .
//   goto 13 on 0123456789
//   goto 42 on Ee
// DFA State  14 [accepting, line  57 <return RELOPLT;>]
//   goto 24 on =
//   goto 25 on >
// DFA State  15 [accepting, line  62 <return EQUAL;>]
// DFA State  16 [accepting, line  60 <return RELOPGT;>]
//   goto 26 on =
// DFA State  17 [accepting, line  50 <return nameOrKeyWord((TCHAR*)getText());>]
//   goto 17 on 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  18 [accepting, line  54 <error(getPos(),_T("Adding missing \" to string con>]
// DFA State  19 [accepting, line  52 <return STRING;>]
// DFA State  20 [accepting, line  68 <return EXPO;>]
// DFA State  21 [accepting, line  74 <{   int i;  while( i = input() ) {    if( i < 0 ) >]
// DFA State  22 [accepting, line  87 <{   int i;  while( i = input() ) {    if( i < 0 ) >]
// DFA State  23 [accepting, line  49 <return HOSTVAR;>]
//   goto 23 on 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  24 [accepting, line  58 <return RELOPLE;>]
// DFA State  25 [accepting, line  59 <return NOTEQ;>]
// DFA State  26 [accepting, line  61 <return RELOPGE;>]
// DFA State  27 [accepting, line  48 <return PARAM;>]
//   goto 27 on 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  28 [accepting, line  69 <return CONCAT;>]
// DFA State  29 [accepting, line  45 <return TIMECONST;>]
// DFA State  30 [accepting, line  44 <return DATECONST;>]
// DFA State  31 [accepting, line  46 <return TIMESTAMPCONST;>]
// DFA State  32 [nonAccepting]
//   goto 32 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t
//   goto 18 on \n
//   goto 32 on \x0b\f
//   goto 39 on \r
//   goto 32 on \x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\s!
//   goto 19 on "
//   goto 32 on #$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[
//   goto 40 on \\
//   goto 32 on ]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f
//              \x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8
//              \xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1
//              \xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda
//              \xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3
//              \xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
// DFA State  33 [accepting, line  43 <return NUMBER;>]
//   goto 33 on 0123456789
//   goto 42 on Ee
// DFA State  34 [nonAccepting]
//   goto 41 on 0123456789
// DFA State  35 [accepting, line  43 <return NUMBER;>]
//   goto 35 on 0123456789
// DFA State  36 [nonAccepting]
//   goto 23 on ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  37 [nonAccepting]
//   goto 27 on ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  38 [nonAccepting]
//   goto 28 on |
// DFA State  39 [nonAccepting]
//   goto 18 on \n
// DFA State  40 [nonAccepting]
//   goto 32 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c
//              \x1d\x1e\x1f\s!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuv
//              wxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95
//              \x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae
//              \xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7
//              \xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0
//              \xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9
//              \xfa\xfb\xfc\xfd\xfe\xff
// DFA State  41 [nonAccepting]
//   goto 43 on -./
//   goto 44 on 0123456789
//   goto 64 on :
// DFA State  42 [nonAccepting]
//   goto 45 on +-
//   goto 35 on 0123456789
// DFA State  43 [nonAccepting]
//   goto 46 on 0123456789
// DFA State  44 [nonAccepting]
//   goto 43 on -./
//   goto 64 on :
// DFA State  45 [nonAccepting]
//   goto 35 on 0123456789
// DFA State  46 [nonAccepting]
//   goto 48 on -./
//   goto 49 on 0123456789
// DFA State  47 [nonAccepting]
//   goto 29 on #
//   goto 50 on 0123456789
//   goto 65 on :
// DFA State  48 [nonAccepting]
//   goto 51 on 0123456789
// DFA State  49 [nonAccepting]
//   goto 48 on -./
// DFA State  50 [nonAccepting]
//   goto 29 on #
//   goto 65 on :
// DFA State  51 [nonAccepting]
//   goto 53 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 30 on #
//   goto 67 on 0123456789
// DFA State  52 [nonAccepting]
//   goto 29 on #
//   goto 54 on 0123456789
// DFA State  53 [nonAccepting]
//   goto 53 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 55 on 0123456789
// DFA State  54 [nonAccepting]
//   goto 29 on #
// DFA State  55 [nonAccepting]
//   goto 56 on 0123456789
//   goto 57 on :
// DFA State  56 [nonAccepting]
//   goto 57 on :
// DFA State  57 [nonAccepting]
//   goto 59 on 0123456789
// DFA State  58 [nonAccepting]
//   goto 53 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 30 on #
// DFA State  59 [nonAccepting]
//   goto 31 on #
//   goto 60 on 0123456789
//   goto 61 on :
// DFA State  60 [nonAccepting]
//   goto 31 on #
//   goto 61 on :
// DFA State  61 [nonAccepting]
//   goto 62 on 0123456789
// DFA State  62 [nonAccepting]
//   goto 31 on #
//   goto 63 on 0123456789
// DFA State  63 [nonAccepting]
//   goto 31 on #
// DFA State  64 [nonAccepting]
//   goto 47 on 0123456789
// DFA State  65 [nonAccepting]
//   goto 52 on 0123456789
// DFA State  66 [nonAccepting]
//   goto 53 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 30 on #
//   goto 58 on 0123456789
// DFA State  67 [nonAccepting]
//   goto 53 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 30 on #
//   goto 66 on 0123456789

// The lexCharMap[] and lexStateMap arrays are used as follows:
//
// nextState = lexNext[lexStateMap[currentState]][lexCharMap[inputChar]];
//
// Character positions in the lexCharMap Array are:
//
//  \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \b   \t   \n   \x0b \f   \r   \x0e \x0f
//  \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f
//  \s   !    "    #    $    %    &    \'   (    )    *    +    ,    -    .    /
//  0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?
//  @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
//  P    Q    R    S    T    U    V    W    X    Y    Z    [    \\   ]    ^    _
//  `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
//  p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~    \x7f
//  \x80 \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f
//  \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f
//  \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf
//  \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf
//  \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf
//  \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde \xdf
//  \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed \xee \xef
//  \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc \xfd \xfe \xff

static unsigned char lexCharMap[256] = {
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   2,   3,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       0,   2,   4,   5,   2,   6,   2,   2,   7,   8,   9,  10,  11,  12,  13,  14,
      15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,   2,  17,  18,  19,  20,
       2,  21,  21,  21,  21,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
      21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,   2,  23,   2,   2,  21,
       2,  21,  21,  21,  21,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
      21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,   2,  24,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2
};

static const unsigned char lexStateMap[68] = {
    /*   0 */   0,   1,   2,   3,   4,   4,   4,   5,   4,   4,
    /*  10 */   4,   6,   7,   8,   9,   4,  10,  11,   4,   4,
    /*  20 */   4,   4,   4,  12,   4,   4,   4,  13,   4,   4,
    /*  30 */   4,   4,  14,  15,  16,  17,  18,  19,  20,  21,
    /*  40 */  22,  23,  24,  25,  26,  17,  27,  28,  29,  30,
    /*  50 */  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
    /*  60 */  41,  42,  43,  44,  45,  46,  47,  48
};

static const char lexNext[49][25] = {
    /*   0 */ { 1, 2,-1, 3,32,34, 4, 5, 6, 7, 8, 9,10,11,12,13,36,14,15,16,37,17,17,-1,38},
    /*   1 */ { 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   2 */ {-1, 2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   3 */ {-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   4 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   5 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   6 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,33,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   7 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,21,-1,-1,-1,-1,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*   8 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,33,-1,13,-1,-1,-1,-1,-1,-1,42,-1,-1},
    /*   9 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,24,25,-1,-1,-1,-1,-1},
    /*  10 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,26,-1,-1,-1,-1,-1,-1},
    /*  11 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,17,-1,-1,-1,-1,-1,17,17,-1,-1},
    /*  12 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,-1,-1,-1,-1,-1,23,23,-1,-1},
    /*  13 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,27,27,-1,-1},
    /*  14 */ {32,18,32,39,19,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,40,32},
    /*  15 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,33,-1,-1,-1,-1,-1,-1,42,-1,-1},
    /*  16 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,41,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  17 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,35,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  18 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,23,23,-1,-1},
    /*  19 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,27,27,-1,-1},
    /*  20 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28},
    /*  21 */ {-1,18,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  22 */ {32,-1,32,-1,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32},
    /*  23 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,43,43,43,44,64,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  24 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,45,-1,45,-1,-1,35,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  25 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,46,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  26 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,43,43,43,-1,64,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  27 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,48,48,48,49,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  28 */ {-1,-1,-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,50,65,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  29 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,51,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  30 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,48,48,48,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  31 */ {-1,-1,-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,65,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  32 */ {53,-1,-1,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,67,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  33 */ {-1,-1,-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,54,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  34 */ {53,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,55,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  35 */ {-1,-1,-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  36 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,56,57,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  37 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,57,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  38 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,59,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  39 */ {53,-1,-1,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  40 */ {-1,-1,-1,-1,-1,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,60,61,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  41 */ {-1,-1,-1,-1,-1,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,61,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  42 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  43 */ {-1,-1,-1,-1,-1,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  44 */ {-1,-1,-1,-1,-1,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  45 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,47,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  46 */ {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,52,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  47 */ {53,-1,-1,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,58,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    /*  48 */ {53,-1,-1,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,66,-1,-1,-1,-1,-1,-1,-1,-1,-1}
};

static const char lexAccept[] = {
    /*   0 */  0,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  10 */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  20 */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  30 */  4,  4,  0,  4,  0,  4,  0,  0,  0,  0,
    /*  40 */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    /*  50 */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    /*  60 */  0,  0,  0,  0,  0,  0,  0,  0
};

#line 9 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"

// nextState(state,c) is given the current state number and input
// character and evaluates to the next state.
#define nextState(state,c) (lexNext[lexStateMap[state]][lexCharMap[c]])

int SqlLex::getNextLexeme() {
  int  state           = 0;     // Current state
  int  lastAcceptState = 0;     // Most recently seen accept state
  int  prevState;               // State before lastAcceptState
  int  nextState;               // Next state
  unsigned int  lookahead;      // Lookahead character
  int  anchor;                  // Anchor mode for most recently seen accepting state

  unTerminateLexeme();
  initMore();
  markStart();

  for(;;) {
    // Check end of file. If there's an unprocessed accepting state,
    // lastAcceptState will be nonzero. In this case, ignore EOF for now so
    // that you can do the accepting action; otherwise, try to open another
    // file and return if you can't.

    for(;;) {
      if(((int)(lookahead = look(1))) != EOF) {
        assert(lookahead < 256);
        nextState = nextState(state, lookahead);
        break;
      } else if(lastAcceptState != 0) {   // still something to do
        nextState = -1;
        break;
      } else if(isWrap()) {               // another file?
        terminateLexeme();
        return 0;                         // EOI
      }
    }
    if(m_debug) {
      debugState(_T("--------"), state, lookahead);
    }

    if(nextState != -1) {
      if(advance() < 0) {                 // Buffer full
        const TCHAR *tooLongMessage = _T("Lexeme too long. Discarding extra characters.");
        error(getPos(), tooLongMessage);

        flush(true);

        if(m_debug) {
          debug(tooLongMessage);
          debugState(_T("--------"), state, look(1));
        }
      }

      if(anchor = lexAccept[nextState]) { // Is this an accept state
        prevState       = state;
        lastAcceptState = nextState;
        markEnd();                        // Mark input at current character
      }                                   // A subsequent gotoMark() returns us to this position.
      state = nextState;
    } else if(lastAcceptState == 0) {     // illegal input
      error(getPos(), _istprint(lookahead)?_T("Ignore bad input:'%c'"):_T("Ignore bad input:%#x"),lookahead);

      if(m_debug) {
        debug(_T("Ignore bad input:'%c'"), lookahead);
      }

      advance();
    } else {
      if(m_debug) {
        debugState(_T("accept--"), lastAcceptState, lookahead);
      }

      gotoMark();                         // Back up to previous accept state
      if(anchor & ANCHOR_END) {           // If end anchor is active
        pushback(1);                      // Push back the CR or LF
      }
      if(anchor & ANCHOR_START) {         // If start anchor is active
        moveStart();                      // Skip the leading newline
      }
      terminateLexeme();                  // Null-terminate the string

      switch(lastAcceptState) {
      case 1:
#line 96 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 2:
#line 97 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 3:
#line 98 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 4:
#line 67 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return MODOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 5:
#line 72 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return LPAR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 6:
#line 73 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return RPAR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 7:
#line 65 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return STAR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 8:
#line 64 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return PLUS;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 9:
#line 71 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return COMMA;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 10:
#line 63 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return MINUS;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 11:
#line 70 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return DOT;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 12:
#line 66 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return DIVOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 13:
      case 33:
      case 35:
#line 43 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return NUMBER;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 14:
#line 57 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return RELOPLT;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 15:
#line 62 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return EQUAL;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 16:
#line 60 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return RELOPGT;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 17:
#line 50 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return nameOrKeyWord((TCHAR*)getText());
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 18:
#line 54 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
                       error(getPos(),_T("Adding missing \" to string constant"));
        return STRING;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 19:
#line 52 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return STRING;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 20:
#line 68 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return EXPO;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 21:
#line 74 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
           {   int i;
        	while( i = input() ) {
        	  if( i < 0 )
        		flushBuf(); 	/* Discard lexeme. */
        	  else if( i == '*'  &&  look(1) == '/' ) {
        		input();
        		break;          	/* Recognized comment.*/
        	  }
        	}
        	if( i == 0 )
        	  error( getPos(), _T("End of file in comment"));
        }
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 22:
#line 87 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
           {   int i;
        	while( i = input() ) {
        	  if( i < 0 )
        		flushBuf();   		/* Discard lexeme. */
        	  else
        		if( i == '\n' ) break;
        	}
        }
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 23:
#line 49 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return HOSTVAR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 24:
#line 58 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return RELOPLE;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 25:
#line 59 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return NOTEQ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 26:
#line 61 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return RELOPGE;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 27:
#line 48 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return PARAM;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 28:
#line 69 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return CONCAT;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 29:
#line 45 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return TIMECONST;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 30:
#line 44 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return DATECONST;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 31:
#line 46 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"
        return TIMESTAMPCONST;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
#line 93 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
      default:
        throwException(_T("%s:Unknown accept state:%d, text=<%s>"), __TFUNCTION__, lastAcceptState,getText());
        break;
      }

      unTerminateLexeme();
      lastAcceptState = 0;

      if(isMore()) {
        state = prevState;                // Back up
        initMore();
      } else {
        state = 0;
        markStart();
      }
    }
  }
}

#line 101 "C:\\Mytools2015\\Dbase\\SqlParse\\Sql.lex"

  /* This part goes to the last part of SqlLex.cpp */

typedef struct {
  TCHAR *m_name;
  int    m_token;
} KeyWord;

static KeyWord keywordTable[] = {
  _T("ACCESS")			 ,ACCESSS			,
  _T("ALL") 			 ,ALL 				,
  _T("AND") 			 ,AND 				,
  _T("AS")   			 ,AS 				,
  _T("ASC") 			 ,ASCENDING			,
  _T("ASCENDING")		 ,ASCENDING			,
  _T("BETWEEN") 		 ,BETWEEN 			,
  _T("BROWSE")			 ,BROWSE			,
  _T("BY")				 ,BY				,
  _T("CAST")		     ,CAST				,
  _T("CHAR")			 ,TYPECHAR			,
  _T("COUNT")			 ,COUNT				,
  _T("CREATE")			 ,CREATE			,
  _T("CURRENTDATE")      ,CURRENTDATE       ,
  _T("CURRENTTIME")      ,CURRENTTIME       ,
  _T("CURRENTTIMESTAMP") ,CURRENTTIMESTAMP  ,
  _T("CURSOR")			 ,CURSOR			,
  _T("DATE")     		 ,TYPEDATE  		,
  _T("DECLARE") 		 ,DECLARE 			,
  _T("DEFAULT") 		 ,DEFAULT 			,
  _T("DELETE")			 ,DELETESYM			,
  _T("DESC")			 ,DESCENDING		,
  _T("DESCENDING")		 ,DESCENDING		,
  _T("DISTINCT")		 ,DISTINCT			,
  _T("DOUBLE")			 ,TYPEDOUBLE		,
  _T("DROP")			 ,DROP				,
  _T("EXCLUSIVE")		 ,EXCLUSIVE			,
  _T("EXISTS")			 ,EXISTS			,
  _T("EXPLAIN") 		 ,EXPLAIN 			,
  _T("FETCH")            ,FETCH             ,
  _T("FLOAT")			 ,TYPEFLOAT			,
  _T("FOR") 			 ,FOR 				,
  _T("FROM")			 ,FROM				,
  _T("GROUP")			 ,GROUP				,
  _T("HAVING")			 ,HAVING			,
  _T("IN")				 ,INSYM				,
  _T("INDEX")			 ,INDEX				,
  _T("INDICATOR")		 ,INDICATOR			,
  _T("INNER")			 ,INNER				,
  _T("INSERT")			 ,INSERT			,
  _T("INT") 			 ,TYPEINT 			,
  _T("INTERSECT")		 ,INTERSECT			,
  _T("INTO")			 ,INTO				,
  _T("IS")				 ,IS				,
  _T("JOIN")			 ,JOIN				,
  _T("KEY") 			 ,KEY 				,
  _T("LEFT")			 ,LEFT				,
  _T("LIKE")			 ,LIKE				,
  _T("LONG")			 ,TYPELONG			,
  _T("MAX") 			 ,MAX 				,
  _T("MIN") 			 ,MIN 				,
  _T("MODE")			 ,MODE				,
  _T("NOT") 			 ,NOT 				,
  _T("NULL")			 ,NULLVAL 			,
  _T("ON")				 ,ON				,
  _T("OR")				 ,OR				,
  _T("ORDER")			 ,ORDER				,
  _T("PRIMARY") 		 ,PRIMARY 			,
  _T("REPEATABLE")		 ,REPEATABLE		,
  _T("SELECT")			 ,SELECT			,
  _T("SET") 			 ,SET 				,
  _T("MINUS")			 ,SETDIFFERENCE		, // symbol MINUS is -
  _T("SHARE")			 ,SHARE				,
  _T("SHORT")			 ,TYPESHORT			,
  _T("SIGNED")			 ,SIGNED			,
  _T("STABLE")			 ,STABLE			,
  _T("SUBSTRING")		 ,SUBSTRING			,
  _T("SUM") 			 ,SUM 				,
  _T("TABLE")			 ,TABLE				,
  _T("TIME")             ,TYPETIME          ,
  _T("TIMESTAMP")        ,TYPETIMESTAMP     ,
  _T("UNION")			 ,UNION				,
  _T("UNIQUE")			 ,UNIQUE			,
  _T("UNSIGNED")		 ,UNSIGNED			,
  _T("UPDATE")			 ,UPDATE			,
  _T("VALUES")			 ,VALUES			,
  _T("VARCHAR") 		 ,TYPEVARCHAR 	    ,
  _T("WCHAR")			 ,TYPEWCHAR			,
  _T("WHERE")			 ,WHERE
};

typedef StrHashMap<int> HashMapType;

class KeyWordMap : public HashMapType {
public:
  KeyWordMap(int tablesize) : HashMapType(tablesize) {
    for(int i = 0; i < ARRAYSIZE(keywordTable); i++) {
      put(keywordTable[i].m_name,keywordTable[i].m_token);
	}
  }
};

static KeyWordMap keywords(752);

static int nameOrKeyWord(const TCHAR *lexeme) {
  TCHAR tmp[100];
  int *p = keywords.get(strToUpperCase(_tcscpy(tmp,lexeme)));
  return p ? *p : NAME;
}

SqlLex::SqlLex(LRparser *parser) {
  m_parser = parser;
}

void SqlLex::verror(const SourcePosition &pos, const TCHAR *format, va_list argptr) {
  if(m_parser != nullptr) {
    m_parser->verror(pos, format, argptr); // redirect to parser
  } else {
    _vtprintf(format, argptr);
  }
}

void SqlLex::findBestHashMapSize() { // static
  for(int tablesize = 57; tablesize < 2000; tablesize++) {
    KeyWordMap ht(tablesize);
	const int maxcl = ht.getMaxChainLength();
	_tprintf(_T("(%4d %d) "), tablesize, maxcl);
	if(maxcl == 1) {
	  _tprintf(_T("\nTablesize=%d gives best hashmap\n"), tablesize);
	  exit(0);
	}
  }
}
#line 112 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
