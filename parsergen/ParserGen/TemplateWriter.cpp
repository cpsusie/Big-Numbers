#include "stdafx.h"
#include <FileNameSplitter.h>
#include "TemplateWriter.h"

static TCHAR *dontEditMessage = _T("/* DO NOT EDIT THIS FILE - it is machine generated */");


KeywordTrigger::KeywordTrigger(KeywordHandler &handler, const String &verboseString) : m_handler(handler) {
  m_verboseString = verboseString;
}

CodeFlags::CodeFlags() {
  m_lineDirectives       = true;
  m_generateBreaks       = true;
  m_generateActions      = true;
  m_generateLookahead    = false;
  m_generateNonTerminals = false;
  m_useTableCompression  = true;
  m_dumpStates           = false;
  m_DFAVerbose           = false;
  m_callWizard           = false;
  m_verbose              = false;
}

TemplateWriter::TemplateWriter(const String &templateName, const String &implOutputDir, const String &headerOutputDir, const CodeFlags &codeFlags)
: m_flags(codeFlags)
{
  m_templateName    = templateName;
  m_implOutputDir   = implOutputDir;
  m_headerOutputDir = headerOutputDir;
  m_output          = NULL;
  openOutput(_T("stdout"));
}

void TemplateWriter::openOutput(const String &name) {
  closeOutput();
  m_output = new MarginFile(name); TRACE_NEW(output);
  m_output->setTrimRight(true);

}

void TemplateWriter::closeOutput() {
  SAFEDELETE(m_output);
}

TemplateWriter::~TemplateWriter() {
  closeOutput();
  Iterator<KeywordTrigger*> it = m_keywords.values().getIterator();
  while(it.hasNext()) {
    KeywordTrigger *kwt = it.next();
    SAFEDELETE(kwt);
  }
}

String getTempFileName(const String &fileName) {
  return FileNameSplitter::getChildName(_T("c:\\temp"), fileName);
}

String TemplateWriter::createTempFileName(const String &ext) { // static
  String fileName = getTempFileName(_T("cXXXXXX"));
  _tmktemp(fileName.cstr());
  return FileNameSplitter(fileName).setExtension(ext).getAbsolutePath();
}

void TemplateWriter::addKeywordHandler(const String &keyword, KeywordHandler &handler, const String &verboseString) {
  KeywordTrigger *kwt = new KeywordTrigger(handler, verboseString); TRACE_NEW(kwt);
  m_keywords.put(keyword, kwt);
}

void TemplateWriter::addMacro(const String &macro, const String &value) {
  m_macroes.put(macro, value);
}

void TemplateWriter::checkChar(const TCHAR *&s, char expected) const {
  if(*s != expected) {
    throwException(_T("Unexpected char:%s. Expected %c"), s, expected);
  }
  s++;
}

// assume *s == '$'. parse the name between $..$ and if name is only letters and is terminated with '$'
// then return name and s will point to character immediately after the last $.
// If macro is not recognized as a correct token $[A-Za-z]+$ then return "" and s will point
// to the character immediately after leading $
String TemplateWriter::parseMacro(const TCHAR *&s) const {
  TCHAR name[256];
  int len = 0;
  checkChar(s,'$');
  const TCHAR *start = s;
  while(_istalpha(*s) && (len < ARRAYSIZE(name)-1)) {
    name[len++] = *(s++);
  }
  if((*s == '$') && (len > 0)) {
    s++;
    name[len] = '\0';
  } else { // this is not a macro
    s = start;
    name[0] = 0;
  }
  return name;
}

String TemplateWriter::expandMacroes(const String &line) const {
  String s = line;
  bool stable;
  do {
    stable = true;
    size_t incr = 0;
    for(intptr_t dollarPos = s.find('$'); dollarPos >= 0; dollarPos = s.find('$', dollarPos+incr)) {
      const TCHAR  *macStart = s.cstr() + dollarPos,*cp = macStart;
      const String  macroName   = parseMacro(cp);
      const size_t  macroLength = cp - macStart;
      const String *value       = (macroName.length() == 0) ? NULL : m_macroes.get(macroName);
      if(value == NULL) {
        incr = macroLength;
      } else {
        s.remove(dollarPos, macroLength);
        s.insert(dollarPos, *value);
        incr = value->length();
        stable = false;
        break;
      }
    }
  } while(!stable);
  return s;
}

void TemplateWriter::generateOutput() {
  String templateText = readTextFile(m_templateName);
  m_currentPos = SourcePositionWithName(m_templateName, 0, 0);
  outputText(templateText);
  closeOutput();
}

void TemplateWriter::outputText(const String &text) {
  for(Tokenizer tok(text,_T("\n\r"),0,TOK_SINGLEDELIMITERS); tok.hasNext();) {
    String tmpLine = tok.next();
    m_currentPos.incrLineNumber();
    String line         = expandMacroes(tmpLine);
    bool   triggerFound = false;
    size_t incr         = 0;
    for(intptr_t dollar = line.find('$'); dollar >= 0; dollar = line.find('$', dollar+incr)) {
      const TCHAR  *macStart = line.cstr() + dollar, *cp = macStart;
      const String  keyword  = parseMacro(cp);
      KeywordTrigger * const *trigger = (keyword.length() == 0) ? NULL : m_keywords.get(keyword);
      if(trigger == NULL) {
        incr = cp - macStart;
        continue;
      }

      if(m_flags.m_verbose && (*trigger)->getVerboseString().length() > 0) {
        _tprintf(_T("%s\n"), (*trigger)->getVerboseString().cstr());
      }
      getOutput().setLeftMargin((int)dollar);
      (*trigger)->getHandler().handleKeyword(*this, line);
      triggerFound = true;
      getOutput().setLeftMargin(0);
      break;
    }
    if(!triggerFound) {
      printf(_T("%s\n"), line.cstr());
    }
  }
}

void TemplateWriter::printf(const TCHAR *format, ...) {
  va_list argptr;
  va_start(argptr, format);
  getOutput().vprintf(format,argptr);
  va_end(argptr);
}

void TemplateWriter::writeLineDirective(const String &sourceName, int lineNumber) {
  TCHAR tmp[512];
  strReplace(tmp, sourceName.cstr(), _T("\\"), _T("\\\\"));
  const int old = getOutput().setLeftMargin(0);
  printf(_T("#line %d \"%s\"\n"), lineNumber, tmp);
  getOutput().setLeftMargin(old);
}

void TemplateWriter::writeSourceText(const SourceText &sourceText) {
  const SourcePositionWithName savePos = m_currentPos;
  m_currentPos = sourceText.m_pos;
  outputLineDirective();
  m_currentPos.setLocation(m_currentPos.getLineNumber()-1,m_currentPos.getColumn());
  outputText(sourceText.m_sourceText);
  m_currentPos = savePos;
  outputLineDirective();
}

SourceTextWriter::SourceTextWriter(const SourceText &sourceText) {
  m_sourceText = sourceText;
}

void SourceTextWriter::handleKeyword(TemplateWriter &writer, String &line) const {
  writer.writeSourceText(m_sourceText);
}

void NewFileHandler::handleKeyword(TemplateWriter &writer, String &line) const {
  intptr_t assign = line.find('=');
  if(assign >= 0) {
    String keyword = trim(substr(line, 0, assign));
    String outputDir;
    if(keyword == _T("$NEWFILE$")) {
      outputDir = writer.getImplOutputDir();
    } else {
      outputDir = writer.getHeaderOutputDir();
    }
    String newOutputName = FileNameSplitter::getChildName(trim(outputDir), substr(line, assign+1, line.length()).trim());
    writer.openOutput(newOutputName);
    writer.printf(_T("%s\n"), dontEditMessage);
  }
}
