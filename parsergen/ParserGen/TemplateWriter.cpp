#include "stdafx.h"
#include <FileNameSplitter.h>
#include "TemplateWriter.h"

static TCHAR *dontEditMessage = _T("/* DO NOT EDIT THIS FILE - it is machine generated */");

KeywordTrigger::KeywordTrigger(KeywordHandler &handler, const String &verboseString)
: m_handler(      handler      )
, m_verboseString(verboseString)
{
}

void KeywordTrigger::verbose() const {
  if(hasVerboseString()) {
    _tprintf(_T("%s\n"), getVerboseString().cstr());
  }
}

TemplateWriter::TemplateWriter()
: m_options(Options::getInstance())
{
  m_output          = nullptr;
  m_outputIsTemp    = false;
  openOutput(_T("stdout"));

  createDefaultHandlers();
  addMacro(_T("OUTPUTDIR"), m_options.m_implOutputDir   );
  addMacro(_T("HEADERDIR"), m_options.m_headerOutputDir );
  addMacro(_T("NAMESPACE"), m_options.m_nameSpace       );
  if(m_options.m_nameSpace.length() > 0) {
    addMacro(_T("PUSHNAMESPACE" ), format(_T("\nnamespace %s {\n" ), m_options.m_nameSpace.cstr()));
    addMacro(_T("POPNAMESPACE"  ), format(_T("}; // namespace %s" ), m_options.m_nameSpace.cstr()));
  } else {
    addMacro(_T("PUSHNAMESPACE" ), _T("$NOLINE$"));
    addMacro(_T("POPNAMESPACE"  ), _T("$NOLINE$"));
  }
}

void TemplateWriter::openOutput(const String &name) {
  closeOutput();
  if(!m_options.m_skipIfEqual || (ACCESS(name, 0) < 0)) {
    m_output             = new MarginFile(name); TRACE_NEW(m_output);
    m_outputIsTemp       = false;
  } else {
    m_wantedOutputName   = name;
    const String newName = FileNameSplitter(name).tempFileName().getAbsolutePath();
    m_output             = new MarginFile(newName); TRACE_NEW(m_output);
    m_outputIsTemp       = true;
  }
  m_output->setTrimRight(true);
}

static bool filesEqual(const String &f1, const String &f2) {
  return readTextFile(f1) == readTextFile(f2);
}

void TemplateWriter::closeOutput() {
  if(m_output) {
    if(!m_outputIsTemp) {
      SAFEDELETE(m_output);
    } else {
      const String tempName = m_output->getAbsolutName();
      SAFEDELETE(m_output);
      if(filesEqual(tempName, m_wantedOutputName)) {
        UNLINK(tempName);
        _tprintf(_T("No changes to file %s\n"), m_wantedOutputName.cstr());
      } else {
        UNLINK(m_wantedOutputName);
        RENAME(tempName, m_wantedOutputName);
      }
      m_wantedOutputName = EMPTYSTRING;
      m_outputIsTemp     = false;
    }
  }
}

TemplateWriter::~TemplateWriter() {
  closeOutput();
  auto it = m_keywords.values().getIterator();
  while(it.hasNext()) {
    KeywordTrigger *kwt = it.next();
    SAFEDELETE(kwt);
  }
  destroyDefaultHandlers();
}

String getTempFileName(const String &fileName) {
  return FileNameSplitter::getChildName(_T("c:\\temp"), fileName);
}

String TemplateWriter::createTempFileName(const String &ext) { // static
  String fileName = getTempFileName(_T("cXXXXXX"));
  _tmktemp(fileName.cstr());
  return FileNameSplitter(fileName).setExtension(ext).getAbsolutePath();
}

void TemplateWriter::addKeywordHandler(const String &keyword, KeywordHandler &handler, const String &verboseString) {
  KeywordTrigger *kwt = new KeywordTrigger(handler, verboseString); TRACE_NEW(kwt);
  m_keywords.put(keyword, kwt);
}

void TemplateWriter::addMacro(const String &macro, const String &value) {
  m_macroes.put(macro, value);
}

void TemplateWriter::checkChar(const TCHAR *&s, char expected) const {
  if(*s != expected) {
    throwException(_T("Unexpected char:%s. Expected %c"), s, expected);
  }
  s++;
}

// assume *s == '$'. parse the name between $..$ and if name is only letters and is terminated with '$'
// then return name and s will point to character immediately after the last $.
// If macro is not recognized as a correct token $[A-Za-z]+$ then return "" and s will point
// to the character immediately after leading $
String TemplateWriter::parseMacro(const TCHAR *&s) const {
  TCHAR name[256];
  int len = 0;
  checkChar(s,'$');
  const TCHAR *start = s;
  while(_istalpha(*s) && (len < ARRAYSIZE(name)-1)) {
    name[len++] = *(s++);
  }
  if((*s == '$') && (len > 0)) {
    s++;
    name[len] = '\0';
  } else { // this is not a macro
    s = start;
    name[0] = 0;
  }
  return name;
}

String TemplateWriter::expandMacroes(const String &line) const {
  String s = line;
  bool stable;
  int  macroCount = 0;
  do {
    stable = true;
    size_t incr  = 0;
    for(intptr_t dollarPos = s.find('$'); dollarPos >= 0; dollarPos = s.find('$', dollarPos+incr)) {
      const TCHAR  *macStart = s.cstr() + dollarPos,*cp = macStart;
      const String  macroName   = parseMacro(cp);
      const size_t  macroLength = cp - macStart;
      const String *value       = (macroName.length() == 0) ? nullptr : m_macroes.get(macroName);
      if(value == nullptr) {
        incr = macroLength;
      } else {
        s.remove(dollarPos, macroLength);
        s.insert(dollarPos, *value);
        incr = value->length();
        stable = false;
        macroCount++;
        break;
      }
    }
  } while(!stable);
  if((macroCount == 1) && (s == _T("\n"))) {
    s = EMPTYSTRING;
  }
  return s;
}

void TemplateWriter::generateOutput() {
  const String templateText = readTextFile(m_options.m_templateName);
  m_currentPos = SourcePositionWithName(m_options.m_templateName, 0, 0);
  outputText(templateText);
  closeOutput();
}

void TemplateWriter::outputLineDirective() {
  if(m_options.m_lineDirectives) {
    writeLineDirective(m_currentPos.getName(), m_currentPos.getLineNumber());
  }
}

void TemplateWriter::outputText(const String &text) {
  for(Tokenizer tok(text,_T("\n\r"),0,TOK_SINGLEDELIMITERS); tok.hasNext();) {
    const String tmpLine = tok.next();
    m_currentPos.incrLineNumber();
    String line         = expandMacroes(tmpLine);
    bool   triggerFound = false;
    size_t incr         = 0;
    for(intptr_t dollar = line.find('$'); dollar >= 0; dollar = line.find('$', dollar+incr)) {
      const TCHAR  *macStart = line.cstr() + dollar, *cp = macStart;
      const String  keyword  = parseMacro(cp);
      KeywordTrigger * const *trigger = (keyword.length() == 0) ? nullptr : m_keywords.get(keyword);
      if(trigger == nullptr) {
        incr = cp - macStart;
        continue;
      }

      if(m_options.m_verbose) (*trigger)->verbose();
      getOutput().setLeftMargin((int)dollar);
      (*trigger)->getHandler().handleKeyword(*this, line);
      triggerFound = true;
      getOutput().setLeftMargin(0);
      break;
    }
    if(!triggerFound) {
      printf(_T("%s\n"), line.cstr());
    }
  }
}

void TemplateWriter::printf(_In_z_ _Printf_format_string_ TCHAR const * const format, ...) {
  va_list argptr;
  va_start(argptr, format);
  getOutput().vprintf(format, argptr);
  va_end(argptr);
}

void TemplateWriter::writeLineDirective(const String &sourceName, int lineNumber) {
  TCHAR tmp[512];
  strReplace(tmp, sourceName.cstr(), _T("\\"), _T("\\\\"));
  const int old = getOutput().setLeftMargin(0);
  printf(_T("#line %d \"%s\"\n"), lineNumber, tmp);
  getOutput().setLeftMargin(old);
}

void TemplateWriter::writeSourceText(const SourceText &sourceText) {
  const SourcePositionWithName savePos = m_currentPos;
  m_currentPos = sourceText.m_pos;
  outputLineDirective();
  m_currentPos.setLocation(m_currentPos.getLineNumber()-1,m_currentPos.getColumn());
  outputText(sourceText.m_sourceText);
  m_currentPos = savePos;
  outputLineDirective();
}

SourceTextWriter::SourceTextWriter(const SourceText &sourceText) {
  m_sourceText = sourceText;
}

void SourceTextWriter::handleKeyword(TemplateWriter &writer, String &line) const {
  writer.writeSourceText(m_sourceText);
}

class NewFileHandler : public KeywordHandler {
public:
  void handleKeyword(TemplateWriter &writer, String &line) const override;
};

class NoLineHandler : public KeywordHandler {
public:
  void handleKeyword(TemplateWriter &writer, String &line) const override {
  }
};

class LineDirectiveHandler : public KeywordHandler {
public:
  void handleKeyword(TemplateWriter &writer, String &line) const override {
    const SourcePositionWithName &pos = writer.getCurrentSourcePos();
    writer.writeLineDirective(pos.getName(), pos.getLineNumber()+1);
  }
};

void NewFileHandler::handleKeyword(TemplateWriter &writer, String &line) const {
  intptr_t assign = line.find('=');
  if(assign >= 0) {
    String keyword = trim(substr(line, 0, assign));
    String outputDir;
    if(keyword == _T("$NEWFILE$")) {
      outputDir = writer.getOptions().m_implOutputDir;
    } else {
      outputDir = writer.getOptions().m_headerOutputDir;
    }
    String newOutputName = FileNameSplitter::getChildName(trim(outputDir), substr(line, assign+1, line.length()).trim());
    writer.openOutput(newOutputName);
    writer.printf(_T("%s\n"), dontEditMessage);
  }
}

void TemplateWriter::createDefaultHandlers() {
  KeywordHandler *newFileHandler       = new NewFileHandler;       TRACE_NEW(newFileHandler      );
  KeywordHandler *noLineHandler        = new NoLineHandler;        TRACE_NEW(noLineHandler       );
  KeywordHandler *lineDirectiveHandler = new LineDirectiveHandler; TRACE_NEW(lineDirectiveHandler);

  addKeywordHandler(_T("NEWFILE"            ), *newFileHandler       );
  addKeywordHandler(_T("NEWHEADERFILE"      ), *newFileHandler       );
  addKeywordHandler(_T("LINEDIRECTIVE"      ), *lineDirectiveHandler );
  addKeywordHandler(_T("NOLINE"             ), *noLineHandler        );

  m_defaultHandlers.setCapacity(3);
  m_defaultHandlers.add(newFileHandler      );
  m_defaultHandlers.add(noLineHandler       );
  m_defaultHandlers.add(lineDirectiveHandler);
}

void TemplateWriter::destroyDefaultHandlers() {
  for(size_t i = 0; i < m_defaultHandlers.size(); i++) {
    KeywordHandler *handler = m_defaultHandlers[i];
    SAFEDELETE(handler);
  }
  m_defaultHandlers.clear();
}
