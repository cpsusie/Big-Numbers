/* DO NOT EDIT THIS FILE - it is machine generated */
#line 21 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
#include "stdafx.h"
#include "clex.h"
#include <ctype.h>

//extern bool nextfile(Scanner &);
//#define yywrap() nextfile(*this)

#line 7 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
// DFA State   0 [nonAccepting]
//   goto  1 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t
//   goto  2 on \n
//   goto  1 on \x0b
//   goto  3 on \f
//   goto  4 on \r
//   goto  3 on \x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f
//   goto  1 on \s
//   goto  5 on !
//   goto 43 on "
//   goto 51 on #
//   goto  3 on $
//   goto  6 on %
//   goto  7 on &
//   goto 56 on \'
//   goto  8 on (
//   goto  9 on )
//   goto 10 on *
//   goto 11 on +
//   goto 12 on ,
//   goto 13 on -
//   goto 14 on .
//   goto 45 on /
//   goto 15 on 0
//   goto 47 on 123456789
//   goto 16 on :
//   goto 17 on ;
//   goto 18 on <
//   goto 19 on =
//   goto 48 on >
//   goto 20 on ?
//   goto  3 on @
//   goto 21 on ABCDEFGHIJKLMNOPQRSTUVWXYZ
//   goto 22 on [
//   goto  3 on \\
//   goto 23 on ]
//   goto 24 on ^
//   goto 21 on _
//   goto  3 on `
//   goto 21 on abcdefghijklmnopqrstuvwxyz
//   goto 25 on {
//   goto 26 on |
//   goto 27 on }
//   goto 44 on ~
//   goto  3 on \x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97
//              \x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0
//              \xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9
//              \xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2
//              \xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb
//              \xfc\xfd\xfe\xff
// DFA State   1 [accepting, line 126 <;>]
//   goto  1 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
// DFA State   2 [accepting, line 124 <;>]
//   goto 42 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 28 on #
// DFA State   3 [accepting, line 127 <_tprintf( _T("Illegal character <%c>\n"), *getText>]
// DFA State   4 [accepting, line 125 <;>]
// DFA State   5 [accepting, line  96 <return UNOP;>]
//   goto 29 on =
// DFA State   6 [accepting, line  98 <return DIVOP;>]
//   goto 32 on =
// DFA State   7 [accepting, line 110 <return AND;>]
//   goto 33 on &
//   goto 32 on =
// DFA State   8 [accepting, line  86 <return LP;>]
// DFA State   9 [accepting, line  87 <return RP;>]
// DFA State  10 [accepting, line  97 <return STAR;>]
//   goto 32 on =
// DFA State  11 [accepting, line  99 <return PLUS;>]
//   goto 34 on +
//   goto 32 on =
// DFA State  12 [accepting, line 117 <return COMMA;>]
// DFA State  13 [accepting, line 100 <return MINUS;>]
//   goto 34 on -
//   goto 32 on =
//   goto 46 on >
// DFA State  14 [accepting, line  93 <gotstructop(); return STRUCTOP;>]
//   goto 64 on .
//   goto 35 on 0123456789
// DFA State  15 [accepting, line  82 <return ICON ;>]
//   goto 35 on .
//   goto 52 on 01234567
//   goto 49 on 89
//   goto 65 on E
//   goto 54 on F
//   goto 57 on LU
//   goto 65 on e
//   goto 54 on f
//   goto 57 on lu
//   goto 66 on x
// DFA State  16 [accepting, line 116 <return COLON;>]
// DFA State  17 [accepting, line 118 <return SEMI;>]
// DFA State  18 [accepting, line 102 <return RELOP;>]
//   goto 38 on <
//   goto 53 on =
// DFA State  19 [accepting, line 109 <return EQUAL;>]
//   goto 29 on =
// DFA State  20 [accepting, line 115 <return QUEST;>]
// DFA State  21 [accepting, line  40 <return NAME;>]
//   goto 21 on 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz
// DFA State  22 [accepting, line  90 <return LB;>]
// DFA State  23 [accepting, line  91 <return RB;>]
// DFA State  24 [accepting, line 111 <return XOR;>]
//   goto 32 on =
// DFA State  25 [accepting, line  88 <return LC;>]
// DFA State  26 [accepting, line 112 <return OR;>]
//   goto 32 on =
//   goto 39 on |
// DFA State  27 [accepting, line  89 <return RC;>]
// DFA State  28 [accepting, line 121 <return HASHMARK;>] Anchor: start
// DFA State  29 [accepting, line 104 <return EQUOP;>]
// DFA State  30 [accepting, line  73 <error(getPos(),_T("Adding missing \" to string con>]
// DFA State  31 [accepting, line  71 <return STRING; // (((\r\n)*{white}*)*{strlit})*>]
// DFA State  32 [accepting, line 107 <return ASSIGNOP;>]
// DFA State  33 [accepting, line 113 <return ANDAND;>]
// DFA State  34 [accepting, line  95 <return INCOP;>]
// DFA State  35 [accepting, line  84 <return FCON ;>]
//   goto 35 on 0123456789
//   goto 65 on E
//   goto 54 on F
//   goto 65 on e
//   goto 54 on f
// DFA State  36 [accepting, line  42 <{   int i;   while( i = input() ) {     if( i < 0 >]
// DFA State  37 [accepting, line  60 <{ int i;   while( i = input()) {     if(i < 0)    >]
// DFA State  38 [accepting, line 101 <return SHIFTOP;>]
//   goto 32 on =
// DFA State  39 [accepting, line 114 <return OROR;>]
// DFA State  40 [accepting, line 119 <return ELLIPSIS;>]
// DFA State  41 [accepting, line 122 <return HASHMARK;>]
// DFA State  42 [nonAccepting]
//   goto 42 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\s
//   goto 28 on #
// DFA State  43 [accepting, line 127 <_tprintf( _T("Illegal character <%c>\n"), *getText>]
//   goto 50 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f
//   goto 30 on \r
//   goto 50 on \x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\s!
//   goto 31 on "
//   goto 50 on #$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[
//   goto 55 on \\
//   goto 50 on ]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f
//              \x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8
//              \xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1
//              \xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda
//              \xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3
//              \xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
// DFA State  44 [accepting, line  96 <return UNOP;>]
// DFA State  45 [accepting, line  98 <return DIVOP;>]
//   goto 36 on *
//   goto 37 on /
//   goto 32 on =
// DFA State  46 [accepting, line  93 <gotstructop(); return STRUCTOP;>]
// DFA State  47 [accepting, line  82 <return ICON ;>]
//   goto 35 on .
//   goto 47 on 0123456789
//   goto 65 on E
//   goto 54 on F
//   goto 57 on LU
//   goto 65 on e
//   goto 54 on f
//   goto 57 on lu
// DFA State  48 [accepting, line 102 <return RELOP;>]
//   goto 53 on =
//   goto 38 on >
// DFA State  49 [accepting, line  84 <return FCON ;>]
//   goto 35 on .
//   goto 49 on 0123456789
//   goto 65 on E
//   goto 54 on F
//   goto 65 on e
//   goto 54 on f
// DFA State  50 [nonAccepting]
//   goto 50 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f
//   goto 30 on \r
//   goto 50 on \x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\s!
//   goto 31 on "
//   goto 50 on #$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[
//   goto 55 on \\
//   goto 50 on ]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f
//              \x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8
//              \xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1
//              \xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda
//              \xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3
//              \xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
// DFA State  51 [accepting, line 127 <_tprintf( _T("Illegal character <%c>\n"), *getText>]
//   goto 59 on d
// DFA State  52 [accepting, line  82 <return ICON ;>]
//   goto 35 on .
//   goto 52 on 01234567
//   goto 49 on 89
//   goto 65 on E
//   goto 54 on F
//   goto 57 on LU
//   goto 65 on e
//   goto 54 on f
//   goto 57 on lu
// DFA State  53 [accepting, line 102 <return RELOP;>]
// DFA State  54 [accepting, line  84 <return FCON ;>]
// DFA State  55 [nonAccepting]
//   goto 50 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c
//              \x1d\x1e\x1f\s!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuv
//              wxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95
//              \x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae
//              \xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7
//              \xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0
//              \xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9
//              \xfa\xfb\xfc\xfd\xfe\xff
// DFA State  56 [accepting, line 127 <_tprintf( _T("Illegal character <%c>\n"), *getText>]
//   goto 61 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c
//              \x1d\x1e\x1f\s!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[
//   goto 63 on \\
//   goto 61 on ]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f
//              \x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8
//              \xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1
//              \xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda
//              \xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3
//              \xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
// DFA State  57 [accepting, line  82 <return ICON ;>]
// DFA State  58 [accepting, line  84 <return FCON ;>]
//   goto 58 on 0123456789
//   goto 54 on Ff
// DFA State  59 [nonAccepting]
//   goto 67 on e
// DFA State  60 [accepting, line  82 <return ICON ;>]
//   goto 57 on \'
// DFA State  61 [nonAccepting]
//   goto 57 on \'
// DFA State  62 [accepting, line  82 <return ICON ;>]
//   goto 62 on 0123456789ABCDEF
//   goto 57 on LU
//   goto 62 on abcdef
//   goto 57 on lu
// DFA State  63 [nonAccepting]
//   goto 61 on \x00\x01\x02\x03\x04\x05\x06\x07\b\t\x0b\f\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c
//              \x1d\x1e\x1f\s!"#$%&
//   goto 60 on \'
//   goto 61 on ()*+,-./
//   goto 68 on 01234567
//   goto 61 on 89:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvw
//   goto 69 on x
//   goto 61 on yz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96
//              \x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf
//              \xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8
//              \xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1
//              \xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa
//              \xfb\xfc\xfd\xfe\xff
// DFA State  64 [nonAccepting]
//   goto 40 on .
// DFA State  65 [nonAccepting]
//   goto 70 on +-
//   goto 58 on 0123456789
// DFA State  66 [nonAccepting]
//   goto 62 on 0123456789ABCDEFabcdef
// DFA State  67 [nonAccepting]
//   goto 71 on f
// DFA State  68 [nonAccepting]
//   goto 57 on \'
//   goto 72 on 01234567
// DFA State  69 [nonAccepting]
//   goto 57 on \'
//   goto 76 on 0123456789ABCDEFabcdef
// DFA State  70 [nonAccepting]
//   goto 58 on 0123456789
// DFA State  71 [nonAccepting]
//   goto 73 on i
// DFA State  72 [nonAccepting]
//   goto 57 on \'
//   goto 61 on 01234567
// DFA State  73 [nonAccepting]
//   goto 75 on n
// DFA State  74 [nonAccepting]
//   goto 57 on \'
//   goto 61 on 0123456789ABCDEFabcdef
// DFA State  75 [nonAccepting]
//   goto 41 on e
// DFA State  76 [nonAccepting]
//   goto 57 on \'
//   goto 74 on 0123456789ABCDEFabcdef

// The lexCharMap[] and lexStateMap arrays are used as follows:
//
// nextState = lexNext[lexStateMap[currentState]][lexCharMap[inputChar]];
//
// Character positions in the lexCharMap Array are:
//
//  \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \b   \t   \n   \x0b \f   \r   \x0e \x0f
//  \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a \x1b \x1c \x1d \x1e \x1f
//  \s   !    "    #    $    %    &    \'   (    )    *    +    ,    -    .    /
//  0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?
//  @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
//  P    Q    R    S    T    U    V    W    X    Y    Z    [    \\   ]    ^    _
//  `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
//  p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~    \x7f
//  \x80 \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f
//  \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f
//  \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf
//  \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf
//  \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf
//  \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde \xdf
//  \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed \xee \xef
//  \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc \xfd \xfe \xff

static unsigned char lexCharMap[256] = {
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   2,   3,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       0,   4,   5,   6,   2,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,
      18,  19,  19,  19,  19,  19,  19,  19,  20,  20,  21,  22,  23,  24,  25,  26,
       2,  27,  27,  27,  27,  28,  29,  30,  30,  30,  30,  30,  31,  30,  30,  30,
      30,  30,  30,  30,  30,  31,  30,  30,  30,  30,  30,  32,  33,  34,  35,  30,
       2,  27,  27,  27,  36,  37,  38,  30,  30,  39,  30,  30,  31,  30,  40,  30,
      30,  30,  30,  30,  30,  31,  30,  30,  41,  30,  30,  42,  43,  44,  45,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2
};

static const unsigned char lexStateMap[77] = {
    /*   0 */   0,   1,   2,   3,   3,   4,   5,   6,   3,   3,
    /*  10 */   5,   7,   3,   8,   9,  10,   3,   3,  11,   4,
    /*  20 */   3,  12,   3,   3,   5,   3,  13,   3,   3,   3,
    /*  30 */   3,   3,   3,   3,   3,  14,   3,   3,   5,   3,
    /*  40 */   3,   3,   2,  15,   3,  16,   3,  17,  18,  19,
    /*  50 */  15,  20,  21,   3,   3,  22,  23,   3,  24,  25,
    /*  60 */  26,  26,  27,  28,  29,  30,  31,  32,  33,  34,
    /*  70 */  35,  36,  37,  38,  39,  40,  41
};

static const char lexNext[42][46] = {
    /*   0 */ {   1,   2,   3,   4,   5,  43,  51,   6,   7,  56,   8,   9,  10,  11,  12,  13,
                 14,  45,  15,  47,  47,  16,  17,  18,  19,  48,  20,  21,  21,  21,  21,  21,
                 22,   3,  23,  24,  21,  21,  21,  21,  21,  21,  25,  26,  27,  44},
    /*   1 */ {   1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   2 */ {  42,  -1,  -1,  -1,  -1,  -1,  28,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   3 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   4 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  29,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   5 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   6 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  33,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   7 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  34,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   8 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  34,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  32,  46,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*   9 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 64,  -1,  35,  35,  35,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  10 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 35,  -1,  52,  52,  49,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  57,
                 -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,  66,  -1,  -1,  -1,  -1},
    /*  11 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  38,  53,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  12 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  21,  21,  21,  -1,  -1,  -1,  -1,  -1,  -1,  21,  21,  21,  21,  21,
                 -1,  -1,  -1,  -1,  21,  21,  21,  21,  21,  21,  -1,  -1,  -1,  -1},
    /*  13 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  39,  -1,  -1},
    /*  14 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  35,  35,  35,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  15 */ {  50,  -1,  50,  30,  50,  31,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,
                 50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,
                 50,  55,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50},
    /*  16 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  36,  -1,  -1,  -1,
                 -1,  37,  -1,  -1,  -1,  -1,  -1,  -1,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  17 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 35,  -1,  47,  47,  47,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  57,
                 -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  18 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  53,  38,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  19 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 35,  -1,  49,  49,  49,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  20 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  59,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  21 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 35,  -1,  52,  52,  49,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  57,
                 -1,  -1,  -1,  -1,  -1,  65,  54,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  22 */ {  50,  -1,  50,  -1,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,
                 50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,
                 50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50},
    /*  23 */ {  61,  -1,  61,  -1,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
                 61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
                 61,  63,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61},
    /*  24 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  58,  58,  58,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  54,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  54,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  25 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  67,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  26 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  27 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  62,  62,  62,  -1,  -1,  -1,  -1,  -1,  -1,  62,  62,  62,  -1,  57,
                 -1,  -1,  -1,  -1,  62,  62,  62,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  28 */ {  61,  -1,  61,  -1,  61,  61,  61,  61,  61,  60,  61,  61,  61,  61,  61,  61,
                 61,  61,  68,  68,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,  61,
                 61,  61,  61,  61,  61,  61,  61,  61,  61,  69,  61,  61,  61,  61},
    /*  29 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 40,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  30 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  70,  -1,  70,
                 -1,  -1,  58,  58,  58,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  31 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  62,  62,  62,  -1,  -1,  -1,  -1,  -1,  -1,  62,  62,  62,  -1,  -1,
                 -1,  -1,  -1,  -1,  62,  62,  62,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  32 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  71,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  33 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  72,  72,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  34 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  76,  76,  76,  -1,  -1,  -1,  -1,  -1,  -1,  76,  76,  76,  -1,  -1,
                 -1,  -1,  -1,  -1,  76,  76,  76,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  35 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  58,  58,  58,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  36 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  73,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  37 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  61,  61,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  38 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  75,  -1,  -1,  -1,  -1,  -1},
    /*  39 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  61,  61,  61,  -1,  -1,  -1,  -1,  -1,  -1,  61,  61,  61,  -1,  -1,
                 -1,  -1,  -1,  -1,  61,  61,  61,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  40 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
    /*  41 */ {  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  57,  -1,  -1,  -1,  -1,  -1,  -1,
                 -1,  -1,  74,  74,  74,  -1,  -1,  -1,  -1,  -1,  -1,  74,  74,  74,  -1,  -1,
                 -1,  -1,  -1,  -1,  74,  74,  74,  -1,  -1,  -1,  -1,  -1,  -1,  -1}
};

static const char lexAccept[] = {
    /*   0 */  0,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  10 */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  20 */  4,  4,  4,  4,  4,  4,  4,  4,  1,  4,
    /*  30 */  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    /*  40 */  4,  4,  0,  4,  4,  4,  4,  4,  4,  4,
    /*  50 */  0,  4,  4,  4,  4,  0,  4,  4,  4,  0,
    /*  60 */  4,  0,  4,  0,  0,  0,  0,  0,  0,  0,
    /*  70 */  0,  0,  0,  0,  0,  0,  0
};

#line 9 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"

// nextState(state,c) is given the current state number and input
// character and evaluates to the next state.
#define nextState(state,c) (lexNext[lexStateMap[state]][lexCharMap[c]])

int CLex::getNextLexeme() {
  int  state           = 0;     // Current state
  int  lastAcceptState = 0;     // Most recently seen accept state
  int  prevState;               // State before lastAcceptState
  int  nextState;               // Next state
  unsigned int  lookahead;      // Lookahead character
  int  anchor;                  // Anchor mode for most recently seen accepting state

  unTerminateLexeme();
  initMore();
  markStart();

  for(;;) {
    // Check end of file. If there's an unprocessed accepting state,
    // lastAcceptState will be nonzero. In this case, ignore EOF for now so
    // that you can do the accepting action; otherwise, try to open another
    // file and return if you can't.

    for(;;) {
      if(((int)(lookahead = look(1))) != EOF) {
        assert(lookahead < 256);
        nextState = nextState(state, lookahead);
        break;
      } else if(lastAcceptState != 0) {   // still something to do
        nextState = -1;
        break;
      } else if(isWrap()) {               // another file?
        terminateLexeme();
        return 0;                         // EOI
      }
    }
    if(m_debug) {
      debugState(_T("--------"), state, lookahead);
    }

    if(nextState != -1) {
      if(advance() < 0) {                 // Buffer full
        const TCHAR *tooLongMessage = _T("Lexeme too long. Discarding extra characters.");
        error(getPos(), tooLongMessage);

        flush(true);

        if(m_debug) {
          debug(tooLongMessage);
          debugState(_T("--------"), state, look(1));
        }
      }

      if(anchor = lexAccept[nextState]) { // Is this an accept state
        prevState       = state;
        lastAcceptState = nextState;
        markEnd();                        // Mark input at current character
      }                                   // A subsequent gotoMark() returns us to this position.
      state = nextState;
    } else if(lastAcceptState == 0) {     // illegal input
      error(getPos(), _istprint(lookahead)?_T("Ignore bad input:'%c'"):_T("Ignore bad input:%#x"),lookahead);

      if(m_debug) {
        debug(_T("Ignore bad input:'%c'"), lookahead);
      }

      advance();
    } else {
      if(m_debug) {
        debugState(_T("accept--"), lastAcceptState, lookahead);
      }

      gotoMark();                         // Back up to previous accept state
      if(anchor & ANCHOR_END) {           // If end anchor is active
        pushback(1);                      // Push back the CR or LF
      }
      if(anchor & ANCHOR_START) {         // If start anchor is active
        moveStart();                      // Skip the leading newline
      }
      terminateLexeme();                  // Null-terminate the string

      switch(lastAcceptState) {
      case 1:
#line 126 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 2:
#line 124 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 3:
      case 43:
      case 51:
      case 56:
#line 127 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        _tprintf( _T("Illegal character <%c>\n"), *getText());
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 4:
#line 125 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 5:
      case 44:
#line 96 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return UNOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 6:
      case 45:
#line 98 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return DIVOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 7:
#line 110 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return AND;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 8:
#line 86 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return LP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 9:
#line 87 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return RP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 10:
#line 97 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return STAR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 11:
#line 99 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return PLUS;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 12:
#line 117 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return COMMA;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 13:
#line 100 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return MINUS;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 14:
      case 46:
#line 93 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        gotstructop(); return STRUCTOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 15:
      case 47:
      case 52:
      case 57:
      case 60:
      case 62:
#line 82 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return ICON ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 16:
#line 116 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return COLON;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 17:
#line 118 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return SEMI;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 18:
      case 48:
      case 53:
#line 102 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return RELOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 19:
#line 109 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return EQUAL;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 20:
#line 115 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return QUEST;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 21:
#line 40 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return NAME;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 22:
#line 90 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return LB;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 23:
#line 91 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return RB;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 24:
#line 111 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return XOR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 25:
#line 88 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return LC;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 26:
#line 112 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return OR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 27:
#line 89 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return RC;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 28:
#line 121 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return HASHMARK;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 29:
#line 104 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return EQUOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 30:
#line 73 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        error(getPos(),_T("Adding missing \" to string constant\n"));
             return STRING;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 31:
#line 71 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return STRING; // (((\r\n)*{white}*)*{strlit})*
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 32:
#line 107 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return ASSIGNOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 33:
#line 113 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return ANDAND;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 34:
#line 95 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return INCOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 35:
      case 49:
      case 54:
      case 58:
#line 84 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return FCON ;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 36:
#line 42 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        {
          int i;
          while( i = input() ) {
            if( i < 0 )
              flushBuf();        // Discard lexeme.
            else if( i == '*' && look(1) == '/' ) {
              input();
              break;             // Recognized comment
            }
          }
          if( i == 0 )
            printf("End of file in comment\n" );
          else
            printf("/* .. */ comment\n");
        }
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 37:
#line 60 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        { int i;
          while( i = input()) {
            if(i < 0)
              flushBuf();
            else
              if(i == '\r')
            break;
          }
          printf("// comment\n");
        }
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 38:
#line 101 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return SHIFTOP;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 39:
#line 114 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return OROR;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 40:
#line 119 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return ELLIPSIS;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
      case 41:
#line 122 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"
        return HASHMARK;
#line 91 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
        break;
#line 93 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
      default:
        throwException(_T("%s:Unknown accept state:%d, text=<%s>"), __TFUNCTION__, lastAcceptState,getText());
        break;
      }

      unTerminateLexeme();
      lastAcceptState = 0;

      if(isMore()) {
        state = prevState;                // Back up
        initMore();
      } else {
        state = 0;
        markStart();
      }
    }
  }
}

#line 129 "C:\\Mytools2015\\ParserGen\\testlex\\C.lex"

  /* This part goes to the last part of clex.cpp */
void gotstructop() {
  printf("Nu er vi i structop\n");
}
#line 112 "C:\\mytools2015\\parsergen\\lib\\lexgencpp.par"
