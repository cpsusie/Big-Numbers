/* DO NOT EDIT THIS FILE - it is machine generated */
#line 29 "C:\\mytools2015\\ParserGen\\dummy\\Dummy.y"
#include "stdafx.h"
#include "dummyparser.h"

#line 33 "C:\\mytools2015\\ParserGen\\lib\\parsergencpp.par"

#pragma warning(disable : 4312)

typedef char TableType;

/****************************************************************************\
* Bitset containing 1-bits for compressed states and 0-bits for              *
* uncompressed states. Used by ParserTable to determine how to               *
* interpret the entry in the action-table                                    *
* Number of bytes in bitset = (statecount-1)/8+1                             *
\****************************************************************************/
static const BYTE compressedSet[1] = { 0x18
}; // Size of table:4 bytes.

/****************************************************************************\
* The action matrix holds the parse action(state,terminal)                   *
* Used in LRParser::parserStep().                                            *
* 2 different formats are used:Compressed and Uncompressed.                  *
*                                                                            *
* Compressed:When there is only 1 possible action in the state.              *
*            or all actions are reduce by the same production.               *
*   If bit 16 (0x8000) is 0, there is only one possible action which is      *
*   encoded as:                                                              *
*      #define   act0001  (void*)((action << 16) | (token&0x7fff)            *
*   State index------+               |                |                      *
*   Highorder 16 bits = action-------+                |                      *
*   Loworder  15 bits = legal token-------------------+                      *
*                                                                            *
*   If bit 16 is 1, the loworder 15 bits is an index.                        *
*      #define   act0002  (void*)((action<<16)  |  0x8000 | (index&0x7fff))  *
*   State index------+               |                |        |             *
*   Highorder 16 bits = action-------+                |        |             *
*   Indicates that this is a multi-item-action-state--+        |             *
*   Loworder  15 bits = index into compressedLasets------------+             *
*                                                                            *
* compressedLasets contains all unique legal lookahead-sets for all          *
* multi-item-action-states.                                                  *
* Number of bytes in each bitset = (terminalcount-1)/8+1                     *
*                                                                            *
* Uncompressed states:                                                       *
*      TableType act0004[] =      { 3, 1, 2, 2,-2, 6, 1 };                   *
*   State index------+              |  |  |                                  *
*   Number of pairs in list---------+  |  |                                  *
*   Legal input symbol-----------------+  |                                  *
*   Action--------------------------------+                                  *
*                                                                            *
* If any uncompressed state has the same actionarray as a previous           *
* generated uncompressed state, a #define is generated to save space.        *
*                                                                            *
*                                                                            *
*   action = getAction(current state, current inputSymbol);                  *
*                                                                            *
*   action <  0   - Reduce by production p, p == -action.                    *
*   action == 0   - Accept. Reduce by production 0.                          *
*   action >  0   - Go to state s (=action),                                 *
*                   and push [s,input,pos] to parser stack.                  *
*                   Then read next symbol from input.                        *
*   action == _ParserError - not found (=unexpected input).                  *
\****************************************************************************/
static const BYTE compressedLasets[1] = {/*  0   2 tokens */  0x03
}; // Size of table:4 bytes.

#define act0003 (void*)0xfffd8000    /* reduce by 3 on tokens in set[0]          */
#define act0004 (void*)0xfffe8000    /* reduce by 2 on tokens in set[0]          */

static const TableType act0000[] = {   2,   1,   2,   2,   3};
static const TableType act0001[] = {   2,   0,   0,   1,   4};
static const TableType act0002[] = {   3,   0,  -4,   1,   2,   2,   3};
static const TableType act0005[] = {   2,   0,  -1,   1,   4};

// Total size of uncompressed actNNNN tables:32 bytes.

static const void *action[6] = {
   act0000,act0001,act0002,act0003,act0004,act0005
}; // Size of table:48 bytes.

/****************************************************************************\
* The successor matrix is used when the parser has reduced by prod A -> alfa *
* Used by LRParser to find newstate = successor(state,A).                    *
*                                                                            *
*                  succ0007[] = { 3, 5,3 , 6,2, 8,5 };                       *
*   Current state-------+         |  | |                                     *
*   Number of pairs in list ------+  | |                                     *
*   NonTerminal A--------------------+ |                                     *
*   Go to this state-------------------+                                     *
\****************************************************************************/
static const TableType succ0000[] = {  1,   4,   1};
static const TableType succ0002[] = {  1,   4,   5};

// Total size of all succNNNN tables:8 bytes.

static const TableType *successor[6] = {
   succ0000,NULL    ,succ0002,NULL    ,NULL    ,NULL
}; // Size of pointertable:48 bytes.

/****************************************************************************\
* The productionLength[] array is indexed by production number and holds     *
* the number of symbols on the right side of each production.                *
\****************************************************************************/
static const unsigned char productionLength[5] = {
  /*   0 */    1,   2,   2,   1,   1
}; // Size of table:8 bytes.

/****************************************************************************\
* The leftSide[] array is indexed by production number, and holds the        *
* nonTerminal symbol on the left side of each production.                    *
\****************************************************************************/
static const TableType leftSide[5] = {
  /*   0 */    3,   4,   4,   4,   4
}; // Size of table:8 bytes.

/****************************************************************************\
* The rightSide[] matrix is indexed by production number and holds           *
* the right side symbols of each production.                                 *
* Compressed and only used for debugging.                                    *
\****************************************************************************/
static const TableType rightSideTable[7] = {
  /*   0 */    4
  /*   1 */ ,  1,  4
  /*   2 */ ,  4,  1
  /*   3 */ ,  2
  /*   4 */ ,  1
}; // Size of table:8 bytes.

/****************************************************************************\
* The symbolName[] array is indexed by symbol and holds                      *
* the name of each symbol (terminal or nonTerminal).                         *
* Used for debugging.                                                        *
\****************************************************************************/
static const TCHAR *symbolName[5] = {
  /*   0 */ _T("EOI"),
  /*   1 */ _T("a"),
  /*   2 */ _T("b"),
  /*   3 */ _T("start"),
  /*   4 */ _T("S")
}; // Total size of strings:24 bytes, size of pointertable:40 bytes.

static const ParserCharTables DummyTables_s(compressedSet, compressedLasets
                                           ,action, successor, productionLength, leftSide
                                           ,rightSideTable, symbolName
                                           ,3, 5, 5, 6);

const ParserTables *DummyTables = &DummyTables_s;
// Size of DummyTables_s: 88 bytes. Size of DummyTables:8 bytes


// Total size of table data:328 bytes.

