/* DO NOT EDIT THIS FILE - it is machine generated */
#line 32 "C:\\Mytools2015\\ParserGen\\dummy\\Dummy.y"
#include "stdafx.h"
#include "dummyparser.h"
#line 36 "C:\\mytools2015\\ParserGen\\lib\\parsergencpp.par"
#include <ParserTablesTemplate.h>
/************************************************************************************\
* The 4 arrays actionCode, termListTable, actionListTable and termSetTable           *
* holds a compressed action-matrix, used by LRParser to find                         *
* action = getAction(S,T), where S is current state, T is next terminal on input     *
*                                                                                    *
* The interpretation of action is:                                                   *
*   action <  0 - Reduce by production p, p == -action.                              *
*   action == 0 - Accept. Reduce by production 0.                                    *
*   action >  0 - Shift to newstate (=action),                                       *
*                 ie. push(newstate), set current state=newstate                     *
*                 and advance input 1 symbol.                                        *
*   action == _ParserError - Unexpected input. Do some recovery, to try to           *
*                 synchronize input and stack, in order to continue parse.           *
*                 (See LRParser::recover() in LRParser.cpp)                          *
*                                                                                    *
* For each state S, a #define is generated and used as element S in array            *
* actionCode. Each define looks as:                                                  *
*                                                                                    *
* #define _acDDDD Code                                                               *
*                                                                                    *
* where DDDD is the statenumber S and Code is an unsigned int with the following     *
* format:                                                                            *
*            0         1         2         3                                         *
* Bit index: 01234567890123456789012345678901                                        *
* Code     : tttttttttttttttCCaaaaaaaaaaaaaaa                                        *
*                                                                                    *
* t        : Bit[ 0-14] : unsigned short                                             *
* a        : Bit[17-31] : signed short                                               *
* CC       : Bit[15-16] : Indicates how to interpret t and a:                        *
*                                                                                    *
* CC == 0: CompCodeTermList (uncompressed)                                           *
*       t: Index into array termListTable, pointing at the first element of          *
*          termList                                                                  *
*       a: Index into array actionListTable, pointing at the first element of        *
*          actionList                                                                *
*                                                                                    *
*       n                  : termListTable[t] = number of elements in termList.      *
*       termList[0..n-1]   : termListTable[t+1..t+n]                                 *
*                            Ordered list of legal terminals                         *
*       actionList[0..n-1] : actionListTable[a..a+n-1] (same length as termList).    *
*                                                                                    *
*       To get action, find index k in termList, so termList[k] == T,k=[0..n-1]      *
*       and set action = actionList[k].                                              *
*       If T is not found, set action = _ParseError.                                 *
*       Note that both termList and actionList may be shared by several states.      *
*                                                                                    *
* CC == 1: CompCodeSplitNode                                                         *
*       t and a are both indices to 2 child entries in actionCode, which can be      *
*       another _acNNNN or an extra node, _snNNNN, whichever is needed (values are   *
*       reused as much as possible, ie. if _snNNNN equals some _acNNNN then no       *
*       _snNNNN is added, but parent entry will point to _acNNNN instead.            *
*       Recursive tree search, with max-recursion level specified in                 *
*       parsegen +c options                                                          *
*                                                                                    *
* CC == 2: CompCodeOneItem (Only 1 legal terminal in the state)                      *
*       t: Legal terminal.                                                           *
*       a: Action.                                                                   *
*                                                                                    *
* CC == 3: CompCodeTermSet (always reduce by same reduce production P = -a)          *
*       t: Index into termSetTable, pointing at the first element of termSet         *
*       a: Action.                                                                   *
*                                                                                    *
*       termSetTable is a list of termSet, bitsets, each with terminalCount bits     *
*       1-bits for legal terminals, 0-bits for illegal terminals.                    *
*                                                                                    *
*       b                  : Number of bytes in each termSet=(terminalCount-1)/8+1   *
*       termSet[0..b-1]    : termSetTable[t..t+b-1]                                  *
*                                                                                    *
*       As for uncompressed states, the same check for existence is done.            *
*       If terminal T is not present in termSet, set action = _ParseError.           *
*       Note that each termSet may be shared by several states.                      *
\************************************************************************************/

#define _ac0000 0x00000000 /* termList    0, actionList    0                        */
#define _ac0001 0x00040003 /* termList    1, actionList    1                        */
#define _ac0002 0x00080006 /* termList    2, actionList    2                        */
#define _ac0003 0xfffb8000 /* Reduce by   3 on tokens in termSet[0]                 */
#define _ac0004 0xfffd8000 /* Reduce by   2 on tokens in termSet[0]                 */
#define _ac0005 0x000e0003 /* termList    1, actionList    3                        */

static const unsigned int actionCode[6] = {
   _ac0000,_ac0001,_ac0002,_ac0003,_ac0004,_ac0005
}; // Size of table:24(x86)/24(x64) bytes.

static const unsigned char termListTable[10] = {
     2,   1,   2                                                                                             /*   0 Used by state  [0]                                */
  ,  2,   0,   1                                                                                             /*   1 Used by states [1,5]                              */
  ,  3,   0,   1,   2                                                                                        /*   2 Used by state  [2]                                */
}; // Size of table:12(x86)/16(x64) bytes.

static const char actionListTable[9] = {
      2,   3                                                                                                 /*   0 Used by state  [0]                                */
  ,   0,   4                                                                                                 /*   1 Used by state  [1]                                */
  ,  -4,   2,   3                                                                                            /*   2 Used by state  [2]                                */
  ,  -1,   4                                                                                                 /*   3 Used by state  [5]                                */
}; // Size of table:12(x86)/16(x64) bytes.

static const unsigned char termSetTable[1] = {
   0x03 /*   0   2 tokens Used by states [3-4]                   */
}; // Size of table:4(x86)/8(x64) bytes.

/************************************************************************************\
* The 3 arrays successorCode, NTindexListTable and stateListTable holds a            *
* compressed succesor-matrix, used by LRParser to find newstate = successor(S,A)     *
* as last part of a reduction with production P, A -> alfa.                          *
* A reduction by production P goes as follows:                                       *
*   Pop L elements from stack, where L = length of alfa;                             *
*   S = state on stacktop;                                                           *
*   A = leftside of the reduce production P;                                         *
*   newstate = successor(S,A);                                                       *
*   push(newstate), and set current state = newstate.                                *
*                                                                                    *
* For each relevant state S, a #define is generated and used as element S in array   *
* successorCode. Each define has the format:                                         *
*                                                                                    *
* #define _suDDDD Code                                                               *
*                                                                                    *
* where DDDD is the statenumber S and Code is an unsigned int with the following     *
* format:                                                                            *
*            0         1         2         3                                         *
* Bit index: 01234567890123456789012345678901                                        *
* Code       iiiiiiiiiiiiiiiCCsssssssssssssss                                        *
*                                                                                    *
* i          : Bit[ 0-14]: unsigned short                                            *
* s          : Bit[17-31]: unsigned short                                            *
* CC         : Bit[15-16]: Indicates how to interpret i and s.                       *
*                                                                                    *
* CC has the same meaning as for actionCode, but only CC={0,2} are used.             *
* CC == 0: Uncompressed Format.                                                      *
*       i: Index into array NTindexListTable, pointing at the first element of       *
*          NTIndexList                                                               *
*       s: Index into array stateListTable, pointing at the first element of         *
*          stateList                                                                 *
*                                                                                    *
*       n                  : NTIndexListTable[i] = number of elements in NTIndexList *
*       NTIndexList[0..n-1]: NTIndexListTable[i+1..i+n]                              *
*                            Ordered list of possible nonterminal-indices.           *
*       stateList[0..n-1]  : stateListTable[s..s+n-1], same length as NTIndexList    *
*                                                                                    *
*       To get newstate, find index k in NTIndexList, so NTIndexList[k] == A',       *
*       and set newstate = stateList[k].                                             *
*       A' = (A - terminalCount) will always exist.                                  *
*       Note that both NTIndexList and stateList may be shared by several states.    *
* CC == 2: Compressed Format, used if there is only 1 possible newstate.             *
*       i: Index A' of nonterminal A, A' = (A - terminalCount).                      *
*       s: New state.                                                                *
*                                                                                    *
\************************************************************************************/

#define _su0000 0x00030001 /* Goto 1 on S                                           */
#define _su0002 0x000b0001 /* Goto 5 on S                                           */

#define nil (unsigned int)-1
static const unsigned int successorCode[6] = {
   _su0000,nil    ,_su0002,nil    ,nil    ,nil
}; // Size of table:24(x86)/24(x64) bytes.

#define NTindexListTable nullptr
#define stateListTable   nullptr

/************************************************************************************\
* The productionLength[] is indexed by production number and holds the number of     *
* symbols on the right side of each production.                                      *
\************************************************************************************/
static const unsigned char productionLength[5] = {
  /*   0 */    1,  2,  2,  1,  1
}; // Size of table:8(x86)/8(x64) bytes.

/************************************************************************************\
* leftSideTable[] is indexed by production number.                                   *
* leftSideTable[p] = A', A' = (A - terminalCount)                                    *
*                        where A is the left side of production p.                   *
* A' = 0..nonterminalCount-1.                                                        *
* p  = 0..productionCount-1                                                          *
\************************************************************************************/
static const unsigned char leftSideTable[5] = {
  /*   0 */    0,  1,  1,  1,  1
}; // Size of table:8(x86)/8(x64) bytes.

/************************************************************************************\
* rightSideTable[] holds a compressed form of the rightsides of all                  *
* productions in the grammar. Only used for debugging.                               *
\************************************************************************************/
static const unsigned char rightSideTable[7] = {
  /*   0 */    4
  /*   1 */ ,  1,  4
  /*   2 */ ,  4,  1
  /*   3 */ ,  2
  /*   4 */ ,  1
}; // Size of table:8(x86)/8(x64) bytes.

/************************************************************************************\
* symbolNames is a space separated string with the names of all symbols used in      *
* grammar, terminals and nonTerminals. Only used for debugging.                      *
\************************************************************************************/
static const char *symbolNames = {
  "EOI"                                               /* T     0               */
  " a"                                                /* T     1               */
  " b"                                                /* T     2               */
  " start"                                            /* NT    3 NTindex=0     */
  " S"                                                /* NT    4 NTindex=1     */
}; // Size of string:16(x86)/16(x64) bytes

static const ParserTablesTemplate<3,5,5,6
                                 ,unsigned char
                                 ,unsigned char
                                 ,unsigned char
                                 ,char
                                 ,unsigned char> DummyTables_s(actionCode      , termListTable     , actionListTable, termSetTable
                                                              ,successorCode   , NTindexListTable  , stateListTable
                                                              ,productionLength, leftSideTable
                                                              ,rightSideTable  , symbolNames
                                                              ,188, 264);

const AbstractParserTables *DummyParser::DummyTables = &DummyTables_s;
// Size of DummyTables_s: 68(x86)/128(x64) bytes. Size of DummyTables:4(x86)/8(x64) bytes

// Total size of table data:188(x86)/264(x64) bytes.
